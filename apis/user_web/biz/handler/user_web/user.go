// Code generated by hertz generator.

package user_web

import (
	"context"
	"errors"
	"net/http"
	"strconv"
	"time"

	"StayEaseGo/apis/user_web/biz/global"
	middleware "StayEaseGo/apis/user_web/biz/handler/middleware"
	base "StayEaseGo/apis/user_web/biz/model/base"
	user_web "StayEaseGo/apis/user_web/biz/model/user_web"
	pb "StayEaseGo/srvs/user_srv/proto/gen"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/utils"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/dgrijalva/jwt-go"
	"github.com/jinzhu/copier"
	"github.com/silenceper/wechat/v2"
	"github.com/silenceper/wechat/v2/cache"
	miniConfig "github.com/silenceper/wechat/v2/miniprogram/config"
)

// Register .
// @router /api/v1/register [POST]
func Register(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user_web.UserRegisterReq
	resp := new(user_web.UserRegisterResp)
	err = c.BindAndValidate(&req)

	if err != nil {
		c.JSON(consts.StatusBadRequest, err.Error())
		return
	}
	rpcResp, err := global.UserSrvClient.Register(ctx, &pb.RegisterReq{
		Mobile:   req.Mobile,
		Password: req.Password,
		AuthKey:  req.Mobile,
		AuthType: global.UserAuthTypeSystem,
		Nickname: req.Nickname,
	})
	if err != nil {
		c.JSON(consts.StatusInternalServerError, err.Error())
		return
	}

	j := middleware.NewJWT()
	expire := time.Now().Add(time.Hour)
	refresh := time.Now().Add(time.Hour / 2)
	claims := middleware.CustomClaims{
		UserID: uint(rpcResp.UserID),
		StandardClaims: jwt.StandardClaims{
			NotBefore: time.Now().Unix(), // Signature valid time
			ExpiresAt: expire.Unix(),
			Issuer:    "ecs",
		},
	}
	token, err := j.CreateToken(claims)
	if err != nil {
		c.JSON(http.StatusInternalServerError, utils.H{
			"msg": "Generate token failed",
		})
		return
	}
	resp.AccessToken = token
	resp.AccessExpire = expire.Format(time.RFC3339)
	resp.RefreshAfter = refresh.Format(time.RFC3339)
	c.JSON(http.StatusOK, resp)
}

// Login .
// @router /api/v1/login [POST]
func Login(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user_web.UserLoginReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(user_web.UserLoginResp)
	rpcResp, err := global.UserSrvClient.Login(ctx, &pb.LoginReq{
		AuthKey:  req.Mobile,
		Password: req.Password,
		AuthType: global.UserAuthTypeSystem,
	})
	c.JSON(consts.StatusOK, resp)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, err.Error())
		return
	}

	j := middleware.NewJWT()
	expire := time.Now().Add(time.Hour)
	refresh := time.Now().Add(time.Hour / 2)
	claims := middleware.CustomClaims{
		UserID: uint(rpcResp.UserID),
		StandardClaims: jwt.StandardClaims{
			NotBefore: time.Now().Unix(), // Signature valid time
			ExpiresAt: expire.Unix(),
			Issuer:    "ecs",
		},
	}
	token, err := j.CreateToken(claims)
	if err != nil {
		c.JSON(http.StatusInternalServerError, utils.H{
			"msg": "Generate token failed",
		})
		return
	}
	resp.AccessToken = token
	resp.AccessExpire = expire.Format(time.RFC3339)
	resp.RefreshAfter = refresh.Format(time.RFC3339)
	c.JSON(http.StatusOK, resp)
}

// WXMiniAuth .
// @router /api/v1/wxlogin [POST]
func WXMiniAuth(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user_web.WXMiniAuthReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(user_web.WXMiniAuthResp)
	//1、Wechat-Mini
	miniprogram := wechat.NewWechat().GetMiniProgram(&miniConfig.Config{
		AppID:     global.GlobalServerConfig.WxMiniConf.AppId,
		AppSecret: global.GlobalServerConfig.WxMiniConf.AppSecret,
		Cache:     cache.NewMemory(),
	})
	authResult, err := miniprogram.GetAuth().Code2Session(req.Code)
	if err != nil || authResult.ErrCode != 0 || authResult.OpenID == "" {
		c.JSON(consts.StatusInternalServerError, err.Error())
		return
	}
	//2、Parsing WeChat-Mini return data
	userData, err := miniprogram.GetEncryptor().Decrypt(authResult.SessionKey, req.EncryptedData, req.Iv)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, err.Error())
		return
	}

	//3、bind user or login.
	var userId int64
	rpcResp, err := global.UserSrvClient.GetUserAuthByAuthKey(ctx, &pb.GetUserAuthByAuthKeyReq{
		AuthType: global.UserAuthTypeSmallWX,
		AuthKey:  authResult.OpenID,
	})
	if err != nil {
		c.JSON(consts.StatusInternalServerError, err.Error())
		return
	}
	if rpcResp.UserAuth == nil || rpcResp.UserAuth.Id == 0 {
		mobile := userData.PhoneNumber
		nickName := mobile[7:]
		registerResp, err := global.UserSrvClient.Register(ctx, &pb.RegisterReq{
			AuthKey:  authResult.OpenID,
			AuthType: global.UserAuthTypeSmallWX,
			Mobile:   mobile,
			Nickname: nickName,
		})
		if err != nil {
			c.JSON(consts.StatusInternalServerError, err.Error())
			return
		}
		j := middleware.NewJWT()
		expire := time.Now().Add(time.Hour)
		refresh := time.Now().Add(time.Hour / 2)
		claims := middleware.CustomClaims{
			UserID: uint(registerResp.UserID),
			StandardClaims: jwt.StandardClaims{
				NotBefore: time.Now().Unix(), // Signature valid time
				ExpiresAt: expire.Unix(),
				Issuer:    "ecs",
			},
		}
		token, err := j.CreateToken(claims)
		if err != nil {
			c.JSON(http.StatusInternalServerError, utils.H{
				"msg": "Generate token failed",
			})
			return
		}
		resp.AccessToken = token
		resp.AccessExpire = expire.Format(time.RFC3339)
		resp.RefreshAfter = refresh.Format(time.RFC3339)
		c.JSON(http.StatusOK, resp)
	} else {
		userId = rpcResp.UserAuth.UserID
		j := middleware.NewJWT()
		expire := time.Now().Add(time.Hour)
		refresh := time.Now().Add(time.Hour / 2)
		claims := middleware.CustomClaims{
			UserID: uint(userId),
			StandardClaims: jwt.StandardClaims{
				NotBefore: time.Now().Unix(), // Signature valid time
				ExpiresAt: expire.Unix(),
				Issuer:    "ecs",
			},
		}
		token, err := j.CreateToken(claims)
		if err != nil {
			c.JSON(http.StatusInternalServerError, utils.H{
				"msg": "Generate token failed",
			})
			return
		}
		resp.AccessToken = token
		resp.AccessExpire = expire.Format(time.RFC3339)
		resp.RefreshAfter = refresh.Format(time.RFC3339)
		c.JSON(http.StatusOK, resp)
	}
	c.JSON(consts.StatusOK, resp)
}

// UserInfo .
// @router /api/v1/user/info [GET]
func UserInfo(ctx context.Context, c *app.RequestContext) {
	var err error
	var req base.Empty
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(user_web.UserInfoResp)
	userID, err := getUserID(c)
	if err != nil {
		c.JSON(consts.StatusUnauthorized, err.Error())
		return
	}
	rpcResp, err := global.UserSrvClient.GetUserInfo(ctx, &pb.GetUserInfoReq{
		Id: userID,
	})
	if err != nil {
		c.JSON(consts.StatusInternalServerError, err.Error())
		return
	}
	userinfo := new(user_web.User)
	_ = copier.Copy(userinfo, rpcResp.User)
	resp.User = userinfo
	c.JSON(consts.StatusOK, resp)
}

func getUserID(c *app.RequestContext) (int64, error) {
	v, exist := c.Get("userID")
	if !exist || v == nil {
		return 0, errors.New("Unauthorized")
	}
	i, err := strconv.ParseInt(v.(string), 10, 64)
	if err != nil {
		return 0, err
	}
	return i, nil
}
