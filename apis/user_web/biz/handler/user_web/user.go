// Code generated by hertz generator.

package user_web

import (
	"context"
	"strconv"
	"time"

	"github.com/pkg/errors"

	"StayEaseGo/apis/user_web/biz/global"
	middleware "StayEaseGo/apis/user_web/biz/handler/middleware"
	base "StayEaseGo/apis/user_web/biz/model/base"
	user_web "StayEaseGo/apis/user_web/biz/model/user_web"
	pb "StayEaseGo/srvs/user_srv/proto/gen"

	"StayEaseGo/pkg/result"
	"StayEaseGo/pkg/xerr"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/dgrijalva/jwt-go"
	"github.com/jinzhu/copier"
	"github.com/silenceper/wechat/v2"
	"github.com/silenceper/wechat/v2/cache"
	miniConfig "github.com/silenceper/wechat/v2/miniprogram/config"
)

// Register .
// @router /api/v1/register [POST]
func Register(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user_web.UserRegisterReq
	resp := new(user_web.UserRegisterResp)
	err = c.BindAndValidate(&req)

	if err != nil {
		result.HttpResult(c, consts.StatusBadRequest, nil, xerr.NewErrCodeMsg(xerr.REUQEST_PARAM_ERROR, err.Error()))
		return
	}
	rpcResp, err := global.UserSrvClient.Register(ctx, &pb.RegisterReq{
		Mobile:   req.Mobile,
		Password: req.Password,
		AuthKey:  req.Mobile,
		AuthType: global.UserAuthTypeSystem,
		Nickname: req.Nickname,
	})
	if err != nil {
		result.HttpResult(c, consts.StatusInternalServerError, nil, errors.Wrapf(err, "register failed, mobile: %s", req.Mobile))
		return
	}

	j := middleware.NewJWT()
	expire := time.Now().Add(time.Hour)
	refresh := time.Now().Add(time.Hour / 2)
	claims := middleware.CustomClaims{
		UserID: uint(rpcResp.UserID),
		StandardClaims: jwt.StandardClaims{
			NotBefore: time.Now().Unix(), // Signature valid time
			ExpiresAt: expire.Unix(),
			Issuer:    "ecs",
		},
	}
	token, err := j.CreateToken(claims)
	if err != nil {
		result.HttpResult(c, consts.StatusInternalServerError, nil, xerr.NewErrCode(xerr.TOKEN_GENERATE_ERROR))
		return
	}
	resp.AccessToken = token
	resp.AccessExpire = expire.Format(time.RFC3339)
	resp.RefreshAfter = refresh.Format(time.RFC3339)
	result.HttpResult(c, consts.StatusOK, resp, nil)
}

// Login .
// @router /api/v1/login [POST]
func Login(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user_web.UserLoginReq
	err = c.BindAndValidate(&req)
	if err != nil {
		result.HttpResult(c, consts.StatusBadRequest, nil, xerr.NewErrCodeMsg(xerr.REUQEST_PARAM_ERROR, err.Error()))
		return
	}

	resp := new(user_web.UserLoginResp)
	rpcResp, err := global.UserSrvClient.Login(ctx, &pb.LoginReq{
		AuthKey:  req.Mobile,
		Password: req.Password,
		AuthType: global.UserAuthTypeSystem,
	})
	if err != nil {
		result.HttpResult(c, consts.StatusInternalServerError, nil, errors.Wrapf(err, "login failed, mobile: %s", req.Mobile))
		return
	}

	j := middleware.NewJWT()
	expire := time.Now().Add(time.Hour)
	refresh := time.Now().Add(time.Hour / 2)
	claims := middleware.CustomClaims{
		UserID: uint(rpcResp.UserID),
		StandardClaims: jwt.StandardClaims{
			NotBefore: time.Now().Unix(), // Signature valid time
			ExpiresAt: expire.Unix(),
			Issuer:    "ecs",
		},
	}
	token, err := j.CreateToken(claims)
	if err != nil {
		result.HttpResult(c, consts.StatusInternalServerError, nil, xerr.NewErrCode(xerr.TOKEN_GENERATE_ERROR))
		return
	}
	resp.AccessToken = token
	resp.AccessExpire = expire.Format(time.RFC3339)
	resp.RefreshAfter = refresh.Format(time.RFC3339)
	result.HttpResult(c, consts.StatusOK, resp, nil)
}

// WXMiniAuth .
// @router /api/v1/wxlogin [POST]
func WXMiniAuth(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user_web.WXMiniAuthReq
	err = c.BindAndValidate(&req)
	if err != nil {
		result.HttpResult(c, consts.StatusBadRequest, nil, xerr.NewErrCodeMsg(xerr.REUQEST_PARAM_ERROR, err.Error()))
		return
	}

	resp := new(user_web.WXMiniAuthResp)
	//1、Wechat-Mini
	miniprogram := wechat.NewWechat().GetMiniProgram(&miniConfig.Config{
		AppID:     global.GlobalServerConfig.WxMiniConf.AppId,
		AppSecret: global.GlobalServerConfig.WxMiniConf.AppSecret,
		Cache:     cache.NewMemory(),
	})
	authResult, err := miniprogram.GetAuth().Code2Session(req.Code)
	if err != nil || authResult.ErrCode != 0 || authResult.OpenID == "" {
		result.HttpResult(c, consts.StatusInternalServerError, nil, xerr.NewErrMsg("get wx auth failed, code: "+req.Code))
		return
	}
	//2、Parsing WeChat-Mini return data
	userData, err := miniprogram.GetEncryptor().Decrypt(authResult.SessionKey, req.EncryptedData, req.Iv)
	if err != nil {
		result.HttpResult(c, consts.StatusInternalServerError, nil, xerr.NewErrMsg("parse wx auth failed, code: "+req.Code))
		return
	}

	//3、bind user or login.
	var userId int64
	rpcResp, err := global.UserSrvClient.GetUserAuthByAuthKey(ctx, &pb.GetUserAuthByAuthKeyReq{
		AuthType: global.UserAuthTypeSmallWX,
		AuthKey:  authResult.OpenID,
	})
	if err != nil {
		result.HttpResult(c, consts.StatusInternalServerError, nil, errors.Wrap(err, "wx auth failed"))
		return
	}
	if rpcResp.UserAuth == nil || rpcResp.UserAuth.Id == 0 {
		mobile := userData.PhoneNumber
		nickName := mobile[7:]
		registerResp, err := global.UserSrvClient.Register(ctx, &pb.RegisterReq{
			AuthKey:  authResult.OpenID,
			AuthType: global.UserAuthTypeSmallWX,
			Mobile:   mobile,
			Nickname: nickName,
		})
		if err != nil {
			result.HttpResult(c, consts.StatusInternalServerError, nil, errors.Wrapf(err, "wx auth failed, openid: %s", req.Code))
			return
		}
		j := middleware.NewJWT()
		expire := time.Now().Add(time.Hour)
		refresh := time.Now().Add(time.Hour / 2)
		claims := middleware.CustomClaims{
			UserID: uint(registerResp.UserID),
			StandardClaims: jwt.StandardClaims{
				NotBefore: time.Now().Unix(), // Signature valid time
				ExpiresAt: expire.Unix(),
				Issuer:    "ecs",
			},
		}
		token, err := j.CreateToken(claims)
		if err != nil {
			result.HttpResult(c, consts.StatusInternalServerError, nil, xerr.NewErrCode(xerr.TOKEN_GENERATE_ERROR))
			return
		}
		resp.AccessToken = token
		resp.AccessExpire = expire.Format(time.RFC3339)
		resp.RefreshAfter = refresh.Format(time.RFC3339)

	} else {
		userId = rpcResp.UserAuth.UserID
		j := middleware.NewJWT()
		expire := time.Now().Add(time.Hour)
		refresh := time.Now().Add(time.Hour / 2)
		claims := middleware.CustomClaims{
			UserID: uint(userId),
			StandardClaims: jwt.StandardClaims{
				NotBefore: time.Now().Unix(), // Signature valid time
				ExpiresAt: expire.Unix(),
				Issuer:    "ecs",
			},
		}
		token, err := j.CreateToken(claims)
		if err != nil {
			result.HttpResult(c, consts.StatusInternalServerError, nil, xerr.NewErrCode(xerr.TOKEN_GENERATE_ERROR))
			return
		}
		resp.AccessToken = token
		resp.AccessExpire = expire.Format(time.RFC3339)
		resp.RefreshAfter = refresh.Format(time.RFC3339)
	}
	result.HttpResult(c, consts.StatusOK, resp, nil)
}

// UserInfo .
// @router /api/v1/user/info [GET]
func UserInfo(ctx context.Context, c *app.RequestContext) {
	var err error
	var req base.Empty
	err = c.BindAndValidate(&req)
	if err != nil {
		result.HttpResult(c, consts.StatusBadRequest, nil, xerr.NewErrCodeMsg(xerr.REUQEST_PARAM_ERROR, err.Error()))
		return
	}

	resp := new(user_web.UserInfoResp)
	userID, err := getUserID(c)
	if err != nil {
		result.HttpResult(c, consts.StatusUnauthorized, nil, err)
		return
	}
	rpcResp, err := global.UserSrvClient.GetUserInfo(ctx, &pb.GetUserInfoReq{
		Id: userID,
	})
	if err != nil {
		result.HttpResult(c, consts.StatusInternalServerError, nil, errors.Wrap(err, "get user info failed"))
		return
	}
	userinfo := new(user_web.User)
	_ = copier.Copy(userinfo, rpcResp.User)
	resp.User = userinfo
	result.HttpResult(c, consts.StatusOK, resp, nil)
}

func getUserID(c *app.RequestContext) (int64, error) {
	v, exist := c.Get("userID")
	if !exist || v == nil {
		return 0, xerr.NewErrCode(xerr.TOKEN_PARSE_ERROR)
	}
	i, err := strconv.ParseInt(v.(string), 10, 64)
	if err != nil {
		return 0, xerr.NewErrCode(xerr.TOKEN_PARSE_ERROR)
	}
	return i, nil
}
